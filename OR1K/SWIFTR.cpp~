//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//


#include "llvm/CodeGen/Passes.h"
#include "llvm/CodeGen/MachineOperand.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/MachineLoopInfo.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/Support/TargetRegistry.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/RegAllocRegistry.h"
#include "llvm/Target/TargetInstrInfo.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Compiler.h"
#include "llvm/ADT/Statistic.h"
#include <iostream>	
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineBasicBlock.h"
#include "llvm/Support/raw_ostream.h"
#include "OR1K.h"
#include "OR1KInstrInfo.h"
#include "OR1KRegisterInfo.h"
#include "OR1KMachineFunctionInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBundle.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Value.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Constants.h"
#include "llvm//MC/MCInst.h"
#include <map>
#include <unordered_map>


namespace llvm{
static cl::opt<bool> EnableSWIFTR(
		"enable-SWIFTR",
		cl::init(false),
		cl::desc("Implement SWIFTR."),
		cl::Hidden);
	struct SWIFTR : public MachineFunctionPass {
		//const	TargetMachine &TM;
		//const TargetInstrInfo *TII;
		public:
			static char ID;
			// Pass identification, replacement for typeid
			//bool runOnMachineFunction(MachineFunction &F);
			//**********************************************************************
			// constructor
			//**********************************************************************


			SWIFTR() : MachineFunctionPass(ID) {    }

			//**********************************************************************
			// runOnMachineFunction
			//**********************************************************************

			std::unordered_map<unsigned int, unsigned int> GPRregistersMap1 ={{ OR1K::R1, OR1K::R10 }, { OR1K::R2, OR1K::R12 }, {OR1K::R3, OR1K::R13 }, {OR1K::R4, OR1K::R14 }, {OR1K::R5, OR1K::R15 }, {OR1K::R6, OR1K::R16 }, {OR1K::R7, OR1K::R17}, {OR1K::R9, OR1K::R19}, {OR1K::R11, OR1K::R8} };
			std::unordered_map<unsigned int, unsigned int> GPRregistersMap2 ={{ OR1K::R1, OR1K::R21 }, { OR1K::R2, OR1K::R22 }, {OR1K::R3, OR1K::R23 }, {OR1K::R4, OR1K::R24 }, {OR1K::R5, OR1K::R25 }, {OR1K::R6, OR1K::R26 }, {OR1K::R7, OR1K::R27}, {OR1K::R9, OR1K::R29}, {OR1K::R10, OR1K::R30}, {OR1K::R11, OR1K::R31} };

			unsigned int getSlaveReg1(unsigned int regNUM){

				std::unordered_map<unsigned int, unsigned int>::const_iterator got = GPRregistersMap1.find(regNUM);
				// Check if iterator points to end of map
				if (got == GPRregistersMap1.end())
				{
					return regNUM;
				}
				else
				{
					return got->second; 
				}

			}
			unsigned int getSlaveReg2(unsigned int regNUM){
				std::unordered_map<unsigned int, unsigned int>::const_iterator got = GPRregistersMap2.find(regNUM);
				// Check if iterator points to end of map
				if (got == GPRregistersMap2.end())
				{
					return regNUM;
				}
				else
				{
					return got->second; 
				}

			}
/*
			bool isSlaveReg(unsigned int regNUM){

				std::unordered_map<unsigned int, unsigned int> allRegsMap;
				allRegsMap.insert(GPRregistersMap.begin(), GPRregistersMap.end());
				allRegsMap.insert(FloatSregsMap.begin(), FloatSregsMap.end());
				allRegsMap.insert(FloatDregsMap.begin(), FloatDregsMap.end());
				allRegsMap.insert(FloatQregsMap.begin(), FloatQregsMap.end());
				std::unordered_map<unsigned int, unsigned int>::const_iterator got = allRegsMap.find(regNUM);
				// Check if iterator points to end of map
				for (std::unordered_map<unsigned int, unsigned int>::iterator  it=allRegsMap.begin(); it!=allRegsMap.end(); ++it )
                                   if (it->second == regNUM) return true;
				return false;

			}

			void insertBr (MachineBasicBlock::instr_iterator I, MachineFunction &MF, MachineBasicBlock* errorBB )
			{


				if (true)
				{
					MachineBasicBlock *MB=I->getParent();
					const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
					DebugLoc DL3= I->getDebugLoc();
					MachineInstr *MItest = BuildMI(MF, DL3 , TII->get(OR1K::Bcc)).addMBB(errorBB).addImm(OR1KCC::NE).addReg(OR1K::CPSR);
					//errs() << "my inst is unconditional Branch: " << *MItest << '\n';

					MB->addSuccessor(errorBB);
					MB->insertAfter(I, MItest);

				}

			}


			bool isOriginalCompare(MachineFunction &MF, MachineBasicBlock::instr_iterator MI){

				if (MI->getOpcode() == OR1K::SUBSri ||  MI->getOpcode() == OR1K::SUBSrr || MI->getOpcode() == OR1K::SUBSrr || MI->getOpcode() == OR1K::SUBSrsr){ MI->dump();
return true;}
//if (MI->definesRegister(OR1K::APSR_NZCV) || MI->modifiesRegister (OR1K::APSR_NZCV, TRI)){ MI->dump();
//return true;}
				if (!MI->isCompare()) return false;

				else {
					for (unsigned int opcount=0 ; opcount < 2 ;opcount++) // the first two operands are sp in pop instructions for OR1KV7a
						if (MI->getOperand(opcount).isReg()){
							if ( isSlaveReg(MI->getOperand(opcount).getReg()) )
								return false;
						} //end if
				}



				return true;
			}
			void addchecksAfterLoads(MachineFunction &MF, MachineBasicBlock* errorBB){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();

				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::instr_iterator I=MBB->instr_begin(), I1=MBB->instr_begin(), E=MBB->instr_end(); I !=E ; ++I, ++I1){
						if (  I->mayLoad()  ){
							//if not cmp before
							bool insertCheck=true;
							for (MachineBasicBlock::instr_iterator MI=MBB->instr_begin(); MI != I; ++MI){
								if(isOriginalCompare(MF, MI))insertCheck=false;
							}
							if(insertCheck){
								DebugLoc DL3= MBB->findDebugLoc(I);
								insertBr(I,MF,errorBB);
								MachineInstr *MIcmp = BuildMI(MF, DL3 , TII->get(OR1K::CMPrr), I->getOperand(0).getReg()).addReg(getSlaveReg(I->getOperand(0).getReg())).addImm(14);
								MBB->insertAfter(I, MIcmp);
							}                                                        

						}// end of if	
					}// end of for
				}//end of for
			}// end of function
			void storeCheck(MachineFunction &MF, MachineBasicBlock* errorBB){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();

				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::instr_iterator I=MBB->instr_begin(), I1=MBB->instr_begin(), E=MBB->instr_end(); I !=E ; ++I, ++I1){
						//if(I->getOpcode() == OR1K::VMRS) I->dump();
						bool check=true;
						if ( I->mayStore() && (I->getOpcode() != OR1K::STMDB_UPD) && (I->getOpcode() != OR1K::VSTMDIA) && (I->getOpcode() != OR1K::VMRS) && (I->getOpcode() != OR1K::STR_PRE_REG) && (I->getOpcode() != OR1K::STMDB) && (I->getOpcode() != OR1K::STMIB) && (I->getOpcode() != OR1K::STMIA) && (I->getOpcode() != OR1K::VSTRS) && (I->getOpcode() != OR1K::VST1q64wb_fixed) && (I->getOpcode() != OR1K::VST1q32) && (I->getOpcode() != OR1K::tPUSH) && (I->getOpcode() != OR1K::t2STR_PRE) && (I->getOpcode() != OR1K::tSTRspi) ){
							DebugLoc DL3= MBB->findDebugLoc(I);
							int storeOpcode=I->getOpcode();
							int loadOpcode=0;
							int cmpOpcode=0;
							switch(storeOpcode){
								case OR1K::STRi12:{
											 loadOpcode=OR1K::LDRi12;
											 cmpOpcode=OR1K::CMPrr;
											 break;}
								case OR1K::VSTRD:{
											loadOpcode=OR1K::VLDRD;
											cmpOpcode=OR1K::VCMPED;
											break;}
								case OR1K::STRrs:{
											loadOpcode=OR1K::LDRrs;
											cmpOpcode=OR1K::CMPrr;
											break;}
								case OR1K::STRBrs:{
											 loadOpcode=OR1K::LDRBrs;
											 cmpOpcode=OR1K::CMPrr;
											 break;}
								case OR1K::STRBi12:{
											  loadOpcode=OR1K::LDRBi12;
											  cmpOpcode=OR1K::CMPrr;
											  break;}
								case OR1K::STMIA:{
											loadOpcode=OR1K::LDMIA;
											cmpOpcode=OR1K::CMPrr;
											break;}
								case OR1K::STMIB:{
											loadOpcode=OR1K::LDMIB;
											cmpOpcode=OR1K::CMPrr;
											break;}
								case OR1K::STMDB:{
											loadOpcode=OR1K::LDMDB;
											cmpOpcode=OR1K::CMPrr;
											break;}
								case OR1K::STRD:{
										       loadOpcode=OR1K::LDRD;
										       cmpOpcode=OR1K::CMPrr;
										       break;}
								case OR1K::t2STRi12:{
											   loadOpcode=OR1K::t2LDRi12;
											   cmpOpcode=OR1K::CMPrr;
											   break;}
								case OR1K::tSTRi:{
											loadOpcode=OR1K::tLDRi;
											cmpOpcode=OR1K::CMPrr;
											break;}
								case OR1K::t2STRDi8:{
											   loadOpcode=OR1K::t2LDRDi8;
											   cmpOpcode=OR1K::CMPrr;
											   break;}
								case OR1K::t2STRs:{
											 loadOpcode=OR1K::t2LDRs;
											 cmpOpcode=OR1K::CMPrr;
											 break;}
								case OR1K::tSTRBr:{
											 loadOpcode=OR1K::tLDRBr;
											 cmpOpcode=OR1K::CMPrr;
											 break;}
								case OR1K::t2STRBi12:{
											    loadOpcode=OR1K::t2LDRBi12;
											    cmpOpcode=OR1K::CMPrr;
											    break;}
								case OR1K::tSTRBi:{
											 loadOpcode=OR1K::tLDRBi;
											 cmpOpcode=OR1K::CMPrr;
											 break;}
								case OR1K::t2STRi8:{
											  loadOpcode=OR1K::t2LDRi8;
											  cmpOpcode=OR1K::CMPrr;
											  break;}
								case OR1K::t2STRBi8:{
											   loadOpcode=OR1K::t2LDRBi8;
											   cmpOpcode=OR1K::CMPrr;
											   break;}
								case OR1K::t2STRBs:{
											  loadOpcode=OR1K::t2LDRBs;
											  cmpOpcode=OR1K::CMPrr;
											  break;}
								case OR1K::tSTRr:{
											loadOpcode=OR1K::tLDRr;
											cmpOpcode=OR1K::CMPrr;
											break;}

								default:{
										I->dump();
										errs()<< "Error Opcode not find\n";
										check=false;
									}
							}
							if(check){
								assert (loadOpcode!=0);
								assert (cmpOpcode!=0);
								MachineInstr *MIload = BuildMI(MF, DL3 , TII->get(loadOpcode));
								MIload->setFlags(0);
								for (unsigned int opcount=0; opcount < I->getNumOperands(); opcount++){ //
									MIload->addOperand(MF, I->getOperand(opcount));              
								} //end of for  
								for (unsigned int opcount=0; opcount < MIload->getNumOperands(); opcount++){ //
									if (MIload->getOperand(opcount).isReg() ){
										if (opcount!= 0) MIload->getOperand(opcount).setReg(getSlaveReg(I->getOperand(opcount).getReg()));
										else  MIload->getOperand(opcount).setReg(I->getOperand(opcount).getReg());
									}
								} //end of for 
								if(cmpOpcode != OR1K::VCMPED) {



									if(false){
										insertBr(I,MF,errorBB);
										MachineInstr *MIcmp = BuildMI(MF, DL3 , TII->get(cmpOpcode), I->getOperand(0).getReg()).addReg(getSlaveReg(I->getOperand(0).getReg())).addImm(14);
										MBB->insertAfter(I, MIcmp); 
									}
									MBB->insertAfter(I, MIload);
								}
								if(cmpOpcode == OR1K::VCMPED) {
									//MachineInstr *MIvmrs = BuildMI(MF, DL3 , TII->get(OR1K::VMRS), OR1K::APSR_NZCV).addReg(OR1K::FPSCR).addImm(14).addImm(14);
									//MIvmrs->setFlags(0);
									//MBB->insertAfter(I, MIvmrs);						
								}
							}

						}// end of if	
					}// end of for
				}//end of for
			}// end of function

			bool isCheckingLoad(MachineBasicBlock::iterator MI){
				if(!(MI->mayLoad())) return false;
				else{
					for (unsigned int opcount=0 ; opcount < MI->getNumOperands() ;opcount++) // the first two operands are sp in pop instructions for OR1KV7a
						if (MI->getOperand(opcount).isReg()){
							if ( isSlaveReg(MI->getOperand(opcount).getReg()))
								return true;
						} //end if

				} // end of else
				return false;

			} // end of function



			void duplicateInstructions(MachineFunction &MF){
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::iterator I=MBB->begin(), I1=MBB->begin(), E=MBB->end(); I !=E ; ++I, ++I1){
						MachineBasicBlock::iterator t;
						if ( (I->getOpcode() == OR1K::LDMIA_UPD) ||(I->getOpcode() == OR1K::LDMIB) || (I->getOpcode() == OR1K::LDMDB)){ // pop instruction is especialI
							I++;
							//printInstruction(I);

						}//enf if
						else if( !(I->isBranch()) &&  !(I->mayStore())    &&  !(I->isCall()) && !(I->isReturn()) && !(I->isCompare()) && (I->getOpcode() != OR1K::LDMIA_UPD) &&  (I->getOpcode() !=OR1K::VMRS) ){
							//printInstruction(I);
							MachineInstr *slaveinst=  MF.CloneMachineInstr (&*I);

							slaveinst->setFlags(0);

							for (unsigned int opcount=0 ; opcount < I->getNumOperands() ;opcount++){ //
								if (I->getOperand(opcount).isReg() )
									slaveinst->getOperand(opcount).setReg(getSlaveReg(I->getOperand(opcount).getReg())); 

							} //end of for

							slaveinst->setFlags(0);
							if(!isCheckingLoad(I)) MBB->insert(I, slaveinst);
						}// end of if	
					}// end of for
				}//end of for
			}// end of function

			void duplicateLoads(MachineFunction &MF){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::instr_iterator I=MBB->instr_begin(), I1=MBB->instr_begin(), E=MBB->instr_end(); I !=E ; ++I, ++I1){
						MachineBasicBlock::instr_iterator t;
						MachineBasicBlock::iterator t1;
						if ( I->getOpcode() == OR1K::LDMIA_UPD ){ // pop instruction is especial
							printInstruction(I);
						}//enf if
						else if(I->mayLoad()){
							//duplicate loads
							MachineInstr *slaveinst=  MF.CloneMachineInstr (&*I);
							slaveinst->getOperand(0).setReg(OR1K::R7);                      
							t= MBB->insert(I, slaveinst);
							// add compare instructions
							MachineInstr *MIcmp = BuildMI(MF, MBB->findDebugLoc(I) , TII->get(OR1K::CMPrr), I->getOperand(0).getReg()).addReg(OR1K::R7).addImm(14);
							t1= MBB->insertAfter(I, MIcmp);
						}// end of if	


					}// end of for
				}//end of for
			}// end of function


			void printInstruction (MachineBasicBlock::instr_iterator I)
			{
				errs() << "Instruction is: " << *I << " and it has operands: " << I->getNumOperands() <<'\n';
				for (int k=0; k< I->getNumOperands(); k++)
				{
					if (I->getOperand(k).isReg() && I->getOperand(k).isDef()) errs() << "op("<<k<<") is register: "<<I->getOperand(k).getReg()<<'\n';
					if (I->getOperand(k).isImm()){ errs() <<" op("<<k<<") is Immediate: "<<I->getOperand(k).getImm()<<'\n';}
					if (I->getOperand(k).isCImm()){	errs() << "op("<<k<<") is Constant Immediate: "<<I->getOperand(k).getCImm()<<'\n';}
					if (I->getOperand(k).isMBB()) {errs() << "op("<<k<<") is Machine BasicBlock: "<<I->getOperand(k).getMBB()->getFullName() <<" Number("<<I->getOperand(k).getMBB()->getNumber()<< "), AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isSymbol()) {errs() << "op("<<k<<") is symbol: "<<I->getOperand(k).getSymbolName() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isFPImm()) {errs() << "op("<<k<<") is FT Imm: "<<I->getOperand(k).getFPImm() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isBlockAddress()) {errs() << "op("<<k<<") is Block Address: "<<I->getOperand(k).getBlockAddress() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}

					if (I->getOperand(k).isMCSymbol()) {errs() << "op("<<k<<") is Machine symbol: "<<I->getOperand(k).getMCSymbol() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}

					if (I->getOperand(k).isMetadata()) {errs() << "op("<<k<<") is Metadata: "<<I->getOperand(k).getMetadata() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}


				}
			}

			std::unordered_map<unsigned int, unsigned int> GPRregistersMap ={{ OR1K::R0, OR1K::R4 }, { OR1K::R1, OR1K::R5 }, {OR1K::R2, OR1K::R6 }, {OR1K::R3, OR1K::R7 }, {OR1K::R11, OR1K::R12 }, {OR1K::SP, OR1K::R8 }, {OR1K::LR, OR1K::R9}, {OR1K::PC, OR1K::R10}};
			std::unordered_map<unsigned int, unsigned int> FloatSregsMap ={{ OR1K::S0, OR1K::S16 }, { OR1K::S1, OR1K::S17 }, {OR1K::S2, OR1K::S18 }, {OR1K::S3, OR1K::S19 }, {OR1K::S4, OR1K::S20 }, {OR1K::S5, OR1K::S21 }, {OR1K::S6, OR1K::S22}, {OR1K::S7, OR1K::S23}, { OR1K::S8, OR1K::S24 }, { OR1K::S9, OR1K::S25 }, {OR1K::S10, OR1K::S26 }, {OR1K::S11, OR1K::S27 }, {OR1K::S12, OR1K::S28 }, {OR1K::S13, OR1K::S29 }, {OR1K::S14, OR1K::S30}, {OR1K::S15, OR1K::S31}};
			std::unordered_map<unsigned int, unsigned int> FloatDregsMap ={{ OR1K::D0, OR1K::D8 }, { OR1K::D1, OR1K::D9 }, {OR1K::D2, OR1K::D10 }, {OR1K::D3, OR1K::D11 }, {OR1K::D4, OR1K::D12 }, {OR1K::D5, OR1K::D13 }, {OR1K::D6, OR1K::D14}, {OR1K::D7, OR1K::D15}, { OR1K::D16, OR1K::D24 }, { OR1K::D17, OR1K::D25 }, {OR1K::D18, OR1K::D26 }, {OR1K::D19, OR1K::D27 }, {OR1K::D20, OR1K::D28 }, {OR1K::D21, OR1K::D29 }, {OR1K::D22, OR1K::D30}, {OR1K::D23, OR1K::D31}};
			std::unordered_map<unsigned int, unsigned int> FloatQregsMap ={{ OR1K::Q0, OR1K::Q4 }, { OR1K::Q1, OR1K::Q5 }, {OR1K::Q2, OR1K::Q6 }, {OR1K::Q3, OR1K::Q7 }, {OR1K::Q7, OR1K::Q4 }, {OR1K::Q8, OR1K::Q12 }, {OR1K::Q9, OR1K::Q13}, {OR1K::Q10, OR1K::Q14}, {OR1K::Q11, OR1K::Q15} };






			void copyMasterRegToSlaves(MachineFunction &MF, MachineBasicBlock::iterator MI){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				for (auto& it: GPRregistersMap){
					MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), it.second).addReg(it.first).addImm(14).addReg(0).addReg(0);
					(MI->getParent())->insertAfter (MI, MImove);
				} // end of for
				///  for (auto& it: FloatDregsMap){
				///	MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), it.second).addReg(it.first).addImm(14).addReg(0).addReg(0);
				///       (MI->getParent())->insertAfter (MI, MImove);
				///     } // end of for

			}// end of function

			void copyMasterRegToSlavesBefore(MachineFunction &MF, MachineBasicBlock::iterator MI){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				for (auto& it: GPRregistersMap){
					MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), it.second).addReg(it.first).addImm(14).addReg(0).addReg(0);
					(MI->getParent())->insertAfter (MI, MImove);
				} // end of for
				///  for (auto& it: FloatDregsMap){
				///	MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), it.second).addReg(it.first).addImm(14).addReg(0).addReg(0);
				///        (MI->getParent())->insert (MI, MImove);
				///    } // end of for

			}// end of function
			void copyLinkRegister(MachineFunction &MF, MachineBasicBlock::iterator MI){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R9).addReg(OR1K::LR).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insertAfter (MI, MImove);
				MachineInstr *MImove1 = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R8).addReg(OR1K::SP).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insertAfter (MI, MImove1);
				MachineInstr *MImove2 = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R12).addReg(OR1K::R11).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insertAfter (MI, MImove2);

			}// end of function
			void copyLinkRegisterBefore(MachineFunction &MF, MachineBasicBlock::iterator MI){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				MachineInstr *MImove = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R9).addReg(OR1K::LR).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insert (MI, MImove);
				MachineInstr *MImove1 = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R8).addReg(OR1K::SP).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insert (MI, MImove1);
				MachineInstr *MImove2 = BuildMI(MF, MI->getDebugLoc() , TII->get(OR1K::MOVr), OR1K::R12).addReg(OR1K::R11).addImm(14).addReg(0).addReg(0);
				(MI->getParent())->insert (MI, MImove2);

			}// end of function



			void copyAfterCalls(MachineFunction &MF){
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					if (MBB == MF.begin()){ 
						MachineBasicBlock::iterator MI=MBB->begin(); 
						while (MI->mayLoad())
							MI++;
						if (MF.getName() != "main") copyLinkRegisterBefore(MF, MI);
						else copyMasterRegToSlaves(MF, MI);
					}// end of if
					for (MachineBasicBlock::iterator I=MBB->begin(), E=MBB->end(); I !=E ; ++I){
						if(I->getOpcode() ==  OR1K::BL)
							copyMasterRegToSlaves(MF, I);
						if(I->getOpcode() ==  OR1K::BL_pred)
							copyLinkRegister(MF, I);
						if(I->getOpcode() == OR1K::LDMIA_UPD || I->getOpcode() == OR1K::STMDB_UPD || I->getOpcode() == OR1K::LDMDB_UPD)
							copyLinkRegister(MF, I);

					}// end of for
				}//end of for
			}// end of function
*/


			void checkFunctionCalls(MachineFunction &MF){
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::iterator I=MBB->begin(), E=MBB->end(); I !=E ; ++I){
						if(I->isCall()){
							I->dump();
							printInstruction(I);
                                                }
					}// end of for
				}//end of for
			}// end of function

			bool runOnMachineFunction(MachineFunction &MF) {	
				if (EnableSWIFTR)
				{
                                     errs() << MF.getName() << "\n";




					//storeCheck(MF, errorBB); //
					//addchecksAfterLoads(MF, errorBB); //MZDC
					triplicateInstructions(MF);
					//MachineBasicBlock* errorBB=makeErrorBB(MF);	
                                        //LoadCheck(MF, errorBB);
                                        //storeCheck(MF, errorBB);
					///checkFunctionCalls(MF); //BL_pred

				}

				return true;
			}
			MachineBasicBlock* makeErrorBB(MachineFunction &MF)
			{
  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
  MachineBasicBlock *errorMBB = MF.CreateMachineBasicBlock();
  MachineFunction::iterator It = (MF.end())->getIterator();
  MF.insert(It, errorMBB);
  errorMBB->addSuccessor(errorMBB);


 MachineInstr *MIAdd = BuildMI(MF, errorMBB->instr_begin()->getDebugLoc() , TII->get(OR1K::ADD)).addReg(OR1K::R22).addReg(OR1K::R22).addReg(OR1K::R22);
 errorMBB->insert (errorMBB->instr_begin(), MIAdd);

				//const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				//MachineBasicBlock *errorBB = MF.CreateMachineBasicBlock();
				//MF.push_back (errorBB);
				//errorBB->addSuccessor(errorBB);

				//MachineBasicBlock::instr_iterator errorBBIter = errorBB->instr_begin();
				//DebugLoc DL3 = errorBB->instr_begin()->getDebugLoc();

				//MachineInstr *MImove = BuildMI(MF, DL3 , TII->get(OR1K::MOVr), OR1K::R5).addReg(OR1K::R5).addImm(14).addReg(0).addReg(0);
				//errorBB->/insertAfter (errorBB->instr_begin(), MImove);
				return errorMBB;
			}



			void printInstruction (MachineBasicBlock::iterator I)
			{
				errs() << "Instruction is: " << *I << " and it has operands: " << I->getNumOperands() <<'\n';
				for (int k=0; k< I->getNumOperands(); k++)
				{
					if (I->getOperand(k).isReg() ) errs() << "op("<<k<<") is register: "<<I->getOperand(k).getReg()<<'\n';
					if (I->getOperand(k).isImm()){ errs() <<" op("<<k<<") is Immediate: "<<I->getOperand(k).getImm()<<'\n';}
					if (I->getOperand(k).isCImm()){	errs() << "op("<<k<<") is Constant Immediate: "<<I->getOperand(k).getCImm()<<'\n';}
					if (I->getOperand(k).isMBB()) {errs() << "op("<<k<<") is Machine BasicBlock: "<<I->getOperand(k).getMBB()->getFullName() <<" Number("<<I->getOperand(k).getMBB()->getNumber()<< "), AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isSymbol()) {errs() << "op("<<k<<") is symbol: "<<I->getOperand(k).getSymbolName() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isFPImm()) {errs() << "op("<<k<<") is FT Imm: "<<I->getOperand(k).getFPImm() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}
					if (I->getOperand(k).isBlockAddress()) {errs() << "op("<<k<<") is Block Address: "<<I->getOperand(k).getBlockAddress() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}

					if (I->getOperand(k).isMCSymbol()) {errs() << "op("<<k<<") is Machine symbol: "<<I->getOperand(k).getMCSymbol() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}

					if (I->getOperand(k).isMetadata()) {errs() << "op("<<k<<") is Metadata: "<<I->getOperand(k).getMetadata() <<" , AND TYPE IS : "<<I->getOperand(k).getType() << '\n';}


				}
			}

//triplicate all instructions but not memory write and control-flow instructions
			void triplicateInstructions(MachineFunction &MF){
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::iterator I=MBB->begin(), E=MBB->end(); I !=E ; ++I){
						if( !(I->isBranch()) &&  !(I->mayStore()) &&  !(I->mayLoad())  &&  !(I->isCall()) && !(I->isReturn()) && !(I->isCompare()) &&  !(I->getOpcode() == OR1K::NOP || (I->getOpcode() > 96 && I->getOpcode() < 129) /*these are compare operations*/) ){
                                 
							printInstruction(I);
							MachineInstr *slaveinst1=  MF.CloneMachineInstr (&*I);
							MachineInstr *slaveinst2=  MF.CloneMachineInstr (&*I);

							slaveinst1->setFlags(0);
							slaveinst2->setFlags(0);

							for (unsigned int opcount=0 ; opcount < I->getNumOperands() ;opcount++){ //
								if (I->getOperand(opcount).isReg() ){
									slaveinst1->getOperand(opcount).setReg(getSlaveReg1(I->getOperand(opcount).getReg())); 
									slaveinst2->getOperand(opcount).setReg(getSlaveReg2(I->getOperand(opcount).getReg())); 
								}

							} //end of for

							 MBB->insert(I, slaveinst1);
							 MBB->insert(I, slaveinst2);
						}// end of if	
					}// end of for
				}//end of for
			}// end of function



			void storeCheck(MachineFunction &MF, MachineBasicBlock* errorBB){
				const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
				for(MachineFunction::iterator MBB = MF.begin(), MBE = MF.end(); MBB != MBE; ++MBB) {
					for (MachineBasicBlock::instr_iterator I=MBB->instr_begin(), I1=MBB->instr_begin(), E=MBB->instr_end(); I !=E ; ++I, ++I1){
						bool check=true;
						if ( I->mayStore() ){
							DebugLoc DL3= MBB->findDebugLoc(I);
							int storeOpcode=I->getOpcode();
							int loadOpcode=0;
							int cmpOpcode=0;
							switch(storeOpcode){
								case OR1K::SW:{
											 loadOpcode=OR1K::LWZ;
											 cmpOpcode=OR1K::SFNE;
											 break;}
								case OR1K::SWA:{
											loadOpcode=OR1K::LWA;
											cmpOpcode=OR1K::SFNE;
											break;}
								case OR1K::SB:{
											loadOpcode=OR1K::LBZ;
											cmpOpcode=OR1K::SFNE;
											break;}
								case OR1K::SH:{
											loadOpcode=OR1K::LHZ;
											cmpOpcode=OR1K::SFNE;
											break;}
								case OR1K::SWf32:{
											loadOpcode=OR1K::LWZf32;
											cmpOpcode=OR1K::SFNE;
											break;}

								default:{
										I->dump();
										errs()<< "Error Opcode not find\n";
										check=false;
									}
							}
							if(check){
								assert (loadOpcode!=0);
								assert (cmpOpcode!=0);
								MachineInstr *MIload = BuildMI(MF, DL3 , TII->get(loadOpcode));
								MIload->setFlags(0);
								for (unsigned int opcount=0; opcount < I->getNumOperands(); opcount++){ //
									MIload->addOperand(MF, I->getOperand(opcount));              
								} //end of for  


								MIload->getOperand(0).setReg(OR1K::R18);
								for (unsigned int opcount=1; opcount < MIload->getNumOperands(); opcount++){ //
									if (MIload->getOperand(opcount).isReg() ){
										MIload->getOperand(opcount).setReg(getSlaveReg1(I->getOperand(opcount).getReg()));
									}
								} //end of for 

								insertBr(I,MF,errorBB);
								MachineInstr *MIcmp = BuildMI(MF, DL3 , TII->get(cmpOpcode), OR1K::R18).addReg(getSlaveReg1(I->getOperand(0).getReg())).addImm(14);
								MBB->insertAfter(I, MIcmp); 									
								MBB->insertAfter(I, MIload);

							}

						}// end of if	
					}// end of for
				}//end of for
			}// end of function
			void insertBr (MachineBasicBlock::instr_iterator I, MachineFunction &MF, MachineBasicBlock* errorBB )
			{
					MachineBasicBlock *MB=I->getParent();
					const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();
					DebugLoc DL3= I->getDebugLoc();
					MachineInstr *MItest = BuildMI(MF, DL3 , TII->get(OR1K::BF)).addMBB(errorBB);
					MB->addSuccessor(errorBB);
					MB->insertAfter(I, MItest);
			}


};

	char SWIFTR::ID = 0;
	FunctionPass *createSWIFTRPass() 
	{
		return new SWIFTR();
	}
}




